package algorithms.additionalTask;

/**
 * –¥–∞–Ω–æ –¥–≤—É–º–µ—Ä–Ω–æ–µ –ø–æ–ª–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã 1...n –∏ 1...m, –≤ —Ç–æ—á–∫–µ 1,1 –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è —Ä–æ–±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç —Ö–æ–¥–∏—Ç—å –ª–∏—à—å –≤–≤–µ—Ä—Ö –∏ –≤–ø—Ä–∞–≤–æ,
 * –ø–æ–º–∏–º–æ —ç—Ç–æ–≥–æ –¥–∞–Ω–∞ –¥–≤–µ—Ä—å —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ (n, m). –ù–∞–π–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—É—Ç–µ–π, –∫–æ—Ç–æ—Ä—ã–º–∏ –º–æ–∂–µ—Ç –¥–≤–∏–≥–∞—Ç—å—Å—è —Ä–æ–±–æ—Ç.
 *
 *      __ __ __
 *  3  |  | x |üö™|
 *     -- -- -----
 *  2  |  | y | x |
 *     ----------
 *  1  |ü§ñ|  |  |
 *     __ __ __
 *     1  2  3
 */

public class DynamicProgramming {

    public static void main(String[] args) {

        long startDyn = System.nanoTime();

        long finishDyn = System.nanoTime() - startDyn;

        long start = System.nanoTime();
        long finish = System.nanoTime() - start;

        System.out.println("non dynamic time " + finish + " ns");
        System.out.println(paths(5, 5));
        System.out.println("dynamic time " + finishDyn + " ns");

        

        // O(2 ^ (n + m))
    }

    // O(2 ^ (n + m)) -> (100, 100) -> 2^200
    static int paths(int n, int m) {
        // –±–∞–∑–∞ —Ä–µ–∫—É—Ä—Å–∏–∏, —Ç–∫ —Ä–æ–±–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –¥–≤–∏–≥–∞—Ç—å—Å—è –≤–ª–µ–≤–æ –∏ –≤–Ω–∏–∑
        if(n < 1 || m < 1) {
            return 0;
        }

        //–¥–≤–µ—Ä—å –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–µ
        if (n == 1 && m == 1) {
            return 1;
        }

        return paths(n-1, m) + paths(n, m - 1);
    }

    //
    static int dynamicPaths(int n, int m) {
        return helper(n, m, new int[n+1][m+1]); // int[n+1][m+1] - –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –Ω–µ 0,0, –∞ 1,1
    }


    // O (n ^ 2)
    static int helper(int n, int m, int[][] arr) {
        // –±–∞–∑–∞ —Ä–µ–∫—É—Ä—Å–∏–∏, —Ç–∫ —Ä–æ–±–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –¥–≤–∏–≥–∞—Ç—å—Å—è –≤–ª–µ–≤–æ –∏ –≤–Ω–∏–∑
        if(n < 1 || m < 1) {
            return 0;
        }

        //—Ä–æ–±–æ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–µ
        if (n == 1 && m == 1) {
            return 1;
        }
        if(arr[n][m] != 0) {
            return arr[n][m];
        }
        arr[n][m] = helper(n-1, m, arr) + helper(n, m-1, arr);
        return arr[n][m];
    }
}
